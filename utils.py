from cryocat import cryomap  # For handling cryo-ET .mrc file formats
from pathlib import Path  # For file path manipulations
from PIL import Image  # For image processing
import imageio  # For saving image files
import subprocess as sp  # For running external commands
import shutil  # For file operations
import os  # For OS-level operations
from os import listdir  # For directory listing
import imageio.v3 as iio  # For reading images
import numpy as np  # For numerical operations

def cryotiger(tsPath, outPath, modelPath, timesToInterpolate):
    print(outPath)
    pngPath = prepareData(tsPath, outPath)
    dstPath = interpolate(pngPath, outPath, modelPath, timesToInterpolate)
    generateOutputMRCTiltSeries(dstPath, outPath, tsPath)

def prepareData(tsPath, outPath):
    # Read the MRC file using cryomap
    mrc = cryomap.read(tsPath)

    # Normalize the MRC data to 0â€“255 range and convert to uint8 format
    mrc = ((mrc - mrc.min()) * (1 / (mrc.max() - mrc.min()) * 255)).astype('uint8')

    # Define the path to save generated PNG files
    pngPath = os.path.join(outPath,'orig')  #These lines are new to create the orig folder
    Path(pngPath).mkdir(parents=True, exist_ok=True)  # Create directory if it doesn't exist

    # Iterate through slices along the Z-axis of the MRC volume and save as PNGs
    for i in range(0, mrc.shape[2]):  # Loop through the third dimension (Z)
        image = Image.fromarray(mrc[:, :, i])  # Extract 2D slice
        if image.mode != 'RGB':  # Ensure image is in RGB format
            image = image.convert('RGB')
        imageio.imwrite(f'{pngPath}/{(i * 10):04}.png', image)  # Save as PNG with incremented name

    return pngPath

def interpolate(pngPath, outPath, pathToModel, timesToInterpolate):
    fnInterp = 'interpolated_frames'

    srcPath = os.path.join(pngPath, fnInterp)
    dstPath = os.path.join(outPath, fnInterp+'_cryoTIGER_model')

    if os.path.exists(dstPath):
        raise Exception("Destination path files or folder exit," \
        "please remove the files before executing this program")

    # Run interpolation using the cryoTIGER model
    process = sp.Popen(f'python3 -m eval.interpolator_cli --pattern "{pngPath}" \
                        --model_path {pathToModel} \
                        --times_to_interpolate {timesToInterpolate}', shell=True)
    process.wait()  # Wait for process to complete

    shutil.move(srcPath, dstPath)
        
    # Move interpolated frames generated by the cryoTIGER model to a specific folder
    if os.path.exists(pngPath):
        shutil.rmtree(pngPath)  # Remove existing folder if it exists

    return dstPath

# Function to process interpolated frames and save them as an MRC file
def process_interpolated_frames(input_path, output_filename):
    
    tomo3d = []  # Initialize list to store 2D slices
    for tomo in sorted(listdir(input_path)):
        fn = os.path.join(input_path, tomo)  # Process each file in sorted order
        img = Image.open(fn).convert('L')#f'{input_path}/{tomo}')  # Convert image to grayscale
        img.save(fn)  # Save the converted image (overwrite)
        
        im = iio.imread(fn)  # Read image data
        tomo3d.append(im)  # Append slice to list
    
    # Stack 2D slices along the Z-axis to reconstruct a 3D volume
    tomo3d = np.stack(tomo3d, axis=2)
    
    # Save the reconstructed 3D volume as an MRC file
    cryomap.write(tomo3d, output_filename, data_type=np.single)

    # Remove interpolated frames generated by the cryoTIGER model
    if os.path.exists(input_path):
        shutil.rmtree(input_path)  # Remove existing folder if it exists


def generateOutputMRCTiltSeries(dstPath, outPath, tsFile, suffix=''):
    # Process interpolated frames for the cryoTIGER model
    _, fn = os.path.split(tsFile)
    fnNoExt, _ = os.path.splitext(fn)
    mrcFn = os.path.join(outPath, fnNoExt+suffix+'_interpolated.mrc')
    print(fnNoExt)
    print(outPath)
    print('mrcFn %s ' % mrcFn)
    process_interpolated_frames(dstPath, mrcFn)




